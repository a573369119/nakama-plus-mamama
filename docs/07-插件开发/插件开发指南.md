# 插件开发指南

## 插件系统概述

Nakama-plus支持强大的插件系统，允许开发者扩展服务器功能。支持Lua和Go两种插件开发语言。

## 插件类型

### 1. Lua插件（推荐）
- **优点**: 热重载、开发快速、安全
- **用途**: 业务逻辑、游戏规则、验证逻辑
- **文件扩展名**: `.lua`

### 2. Go插件（高级）
- **优点**: 高性能、直接访问Go API
- **用途**: 高性能计算、系统级扩展
- **文件扩展名**: `.so`

## Lua插件开发

### 基本结构
```lua
-- main.lua - 主插件文件
local nk = require("nakama")

-- 初始化函数（服务器启动时调用）
local function init(context)
  nk.logger_info("插件初始化完成")
end

-- RPC函数示例
local function get_user_stats(context, payload)
  local user_id = context.user_id
  
  -- 参数验证
  if not user_id then
    return { error = "用户ID不能为空" }
  end
  
  -- 数据库查询
  local result = nk.sql_query([[
    SELECT COUNT(*) as match_count, 
           AVG(score) as avg_score
    FROM user_matches 
    WHERE user_id = $1
  ]], { user_id })
  
  return { 
    user_id = user_id,
    match_count = result[1].match_count,
    avg_score = result[1].avg_score
  }
end

-- 注册函数
nk.register_rpc(get_user_stats, "get_user_stats")
nk.register_init(init)

return {
  get_user_stats = get_user_stats
}
```

### 常用API

#### 数据库操作
```lua
-- SQL查询
local result = nk.sql_query("SELECT * FROM users WHERE id = $1", { user_id })

-- SQL执行
nk.sql_exec("UPDATE users SET score = score + 1 WHERE id = $1", { user_id })

-- 存储操作
nk.storage_write({
  { collection = "user_data", key = "profile", user_id = user_id, value = profile_data }
})

nk.storage_read({
  { collection = "user_data", key = "profile", user_id = user_id }
})
```

#### 用户管理
```lua
-- 获取用户信息
local users = nk.users_get_id({ user_id })

-- 更新用户账户
nk.account_update_id(user_id, {
  display_name = "新昵称",
  avatar_url = "https://example.com/avatar.jpg"
})

-- 封禁用户
nk.ban_users({ user_id }, nil, 3600, "违反游戏规则")
```

#### 匹配系统
```lua
-- 创建匹配
local match_id = nk.match_create("game_mode", {
  max_players = 4,
  label = "快速匹配"
})

-- 发送匹配数据
nk.match_data_send(match_id, 0, "MATCH_START", { map = "desert" })
```

### 事件处理
```lua
-- 用户注册事件
local function on_register(context, user)
  nk.logger_info(string.format("用户注册: %s (%s)", user.username, user.id))
  
  -- 发送欢迎消息
  nk.notification_send({
    { user_id = user.id, subject = "欢迎", content = { message = "欢迎加入游戏！" } }
  })
end

-- 注册事件处理器
nk.register_event_before("RegisterAccount", on_register)
```

## Go插件开发

### 项目结构
```
my-plugin/
├── go.mod          # 模块定义
├── main.go         # 主文件
├── handlers/       # 处理器目录
└── types/          # 类型定义
```

### 基本示例
```go
// main.go
package main

import (
    "context"
    "encoding/json"
    "log"
    
    "github.com/heroiclabs/nakama-common/runtime"
)

// 初始化函数
func InitModule(ctx context.Context, logger runtime.Logger, db *runtime.DB, nk runtime.NakamaModule, initializer runtime.Initializer) error {
    logger.Info("Go插件初始化")
    
    // 注册RPC函数
    if err := initializer.RegisterRpc("get_stats", GetStats); err != nil {
        return err
    }
    
    return nil
}

// RPC函数
func GetStats(ctx context.Context, logger runtime.Logger, db *runtime.DB, nk runtime.NakamaModule, payload string) (string, error) {
    // 解析请求
    var request struct {
        UserID string `json:"user_id"`
    }
    if err := json.Unmarshal([]byte(payload), &request); err != nil {
        return "", runtime.NewError("无效的请求格式", 3)
    }
    
    // 查询用户数据
    objects, err := nk.StorageRead(ctx, []*runtime.StorageRead{
        {
            Collection: "user_data",
            Key:        "stats",
            UserID:     request.UserID,
        },
    })
    if err != nil {
        return "", err
    }
    
    // 返回结果
    response := map[string]interface{}{
        "user_id": request.UserID,
        "stats":   objects,
    }
    
    responseBytes, _ := json.Marshal(response)
    return string(responseBytes), nil
}
```

### 构建Go插件
```bash
# 构建插件
go build --buildmode=plugin -o my-plugin.so

# 或者使用项目构建脚本
go build --trimpath --mod=vendor --buildmode=plugin -o ./backend.so
```

## 插件部署

### 开发环境部署
```yaml
# docker-compose.yml
services:
  nakama:
    image: nakama-plus:latest
    volumes:
      - ./plugins:/nakama/data/modules  # 挂载插件目录
    environment:
      - NAKAMA_RUNTIME_PATH=/nakama/data/modules
```

### 生产环境部署
```yaml
# 使用Docker镜像包含插件
FROM nakama-plus:latest

# 复制插件文件
COPY plugins/ /nakama/data/modules/

# 保持原有启动命令
CMD ["/nakama/nakama-plus"]
```

## 调试和测试

### 日志调试
```lua
-- Lua插件日志
nk.logger_debug("调试信息: %s", debug_data)
nk.logger_info("普通信息")
nk.logger_warn("警告信息")  
nk.logger_error("错误信息")
```

```go
// Go插件日志
logger.Debug("调试信息: %s", debugData)
logger.Info("普通信息")
logger.Warn("警告信息")
logger.Error("错误信息")
```

### 单元测试
```lua
-- 测试框架示例
local function test_get_user_stats()
  local context = { user_id = "test-user" }
  local payload = '{"user_id":"test-user"}'
  
  local result = get_user_stats(context, payload)
  assert(result.user_id == "test-user")
  assert(result.match_count >= 0)
end
```

```go
// Go测试示例
func TestGetStats(t *testing.T) {
    ctx := context.Background()
    payload := `{"user_id":"test-user"}`
    
    result, err := GetStats(ctx, nil, nil, nil, payload)
    if err != nil {
        t.Fatalf("GetStats failed: %v", err)
    }
    
    var response map[string]interface{}
    json.Unmarshal([]byte(result), &response)
    
    if response["user_id"] != "test-user" {
        t.Errorf("Expected user_id 'test-user', got %v", response["user_id"])
    }
}
```

## 性能优化

### Lua插件优化
```lua
-- 使用本地变量缓存频繁访问的模块
local nk = require("nakama")

-- 避免在循环中创建表
local function process_users(users)
    local results = {}
    for i, user in ipairs(users) do
        -- 预分配表大小
        results[i] = { id = user.id, name = user.username }
    end
    return results
end

-- 使用字符串缓存
local SQL_QUERY = "SELECT * FROM users WHERE id = $1"
local result = nk.sql_query(SQL_QUERY, { user_id })
```

### Go插件优化
```go
// 使用连接池
var db *sql.DB

func InitModule(ctx context.Context, logger runtime.Logger, db *runtime.DB, nk runtime.NakamaModule, initializer runtime.Initializer) error {
    // 初始化数据库连接池
    var err error
    db, err = sql.Open("postgres", "connection_string")
    if err != nil {
        return err
    }
    db.SetMaxOpenConns(25)
    db.SetMaxIdleConns(25)
    
    return nil
}

// 使用缓存
var cache = make(map[string]interface{})

func GetCachedData(ctx context.Context, key string) (interface{}, error) {
    if data, exists := cache[key]; exists {
        return data, nil
    }
    
    // 从数据库获取数据
    data, err := fetchFromDB(ctx, key)
    if err != nil {
        return nil, err
    }
    
    cache[key] = data
    return data, nil
}
```

## 安全最佳实践

### 输入验证
```lua
-- Lua输入验证
local function safe_rpc(context, payload)
    -- 验证用户权限
    if not context.user_id then
        return { error = "未授权访问" }
    end
    
    -- 验证输入格式
    local data = nk.json_decode(payload)
    if not data or type(data) ~= "table" then
        return { error = "无效的JSON格式" }
    end
    
    -- SQL注入防护（使用参数化查询）
    nk.sql_query("SELECT * FROM users WHERE id = $1", { data.user_id })
end
```

```go
// Go输入验证
func SafeRPC(ctx context.Context, payload string) (string, error) {
    // 验证JSON格式
    var data map[string]interface{}
    if err := json.Unmarshal([]byte(payload), &data); err != nil {
        return "", runtime.NewError("无效的JSON格式", 3)
    }
    
    // 验证必需字段
    userID, ok := data["user_id"].(string)
    if !ok || userID == "" {
        return "", runtime.NewError("user_id不能为空", 3)
    }
    
    // SQL注入防护
    query := "SELECT * FROM users WHERE id = $1"
    // 使用参数化查询...
}
```

## 插件管理

### 版本控制
```bash
# 使用Git管理插件版本
git init
git add .
git commit -m "feat: 添加用户统计插件"

# 创建版本标签
git tag v1.0.0
git push origin v1.0.0
```

### 部署流水线
```yaml
# GitHub Actions示例
name: Deploy Plugin
on:
  push:
    tags:
      - 'v*'

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Build Plugin
        run: |
          go build -o plugin.so
      - name: Deploy to Server
        uses: appleboy/scp-action@v0.1.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_KEY }}
          source: "plugin.so"
          target: "/opt/nakama/plugins/"
```

插件系统为Nakama-plus提供了强大的扩展能力，让开发者可以灵活定制游戏服务器功能。